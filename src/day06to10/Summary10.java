package day06to10;

/*

상속 Inheritance
new연산 없이 다른 클래스의 기능을 사용할 수 있다.
기존 클래스에 새로운 기능을 추가할 수 있다.
부모 클래스의 메소드를 변경하여 사용할 수 있다(overriding및 다형성)
Extends를 사용하여 상속 받는다.

식은
class 자식클래스 extends 부모클래스 {}
자식클래스는 자신의 코드와 부모의 코드 전부 사용 가능

자식클래스와 부모클래스에 같은 이름의 객체나 메소드가 있을경우
불러올때에 폴더까지 보고 잘 선택을 해야하는데
앞에 super.를 적어주면 부모쪽의 객체나 메소드를 선택한다.

super는 무조건 생성자 첫줄에 넣어야 작동한다.
클래스코드나 생성자코드 바로 아래 넣어야 한다.

기본생성자가 없을때 super를 이용해 부모 생성자에 값을 주도록 할 수 있다.

super.가 들어올 수 있는 private
protected는 외부의 호출은 막지만 상속된 메소드에는 호출 가능하다

호출받았을때 기능을 찾는 순서는 자식이 작은지역, 부모가 큰지역 으로 생각하면 쉽다
먼저 자신의 클래스에서 기능을 찾고 없으면 부모클래서에서 찾은 뒤 이후 다시 돌아와 자신의 식을 수행한다.

클래스는 두개를 상속받을 수 없다(나중에 할 수 있는 방법 배움)
그래도 2개 상속받고 싶으면 물림상속진행해야 한다.
B에서 A를 상속받고, C에서 B를 상속받으면 C는 A와B 둘 다 이용할 수 있다.


예외
프로그램에서 문제가 발생 될 소기가 있는 내용을 처리
개발자의 의도와 다르게 동작하는 경우 처리
프로그램의 중단을 막을 수 있다


-예외처리
try, catch를 통해 처리한다. finally와 같이 사용할 수 있다.

식은
try {
오류가 발생할 수 있는 코드
}catch(오류클래스 변수) {
오류 발생시 대응할 코드
}finally {
}

오류 클래스는 실행했을때 파란색으로 뜨는 -Exception 같은 문장이고,
catch에서 오류클래스에 할당 된 변수를 출력할 경우 오류상황의 클래스명을 다시 보여준다.
sysout을 써도 괜찮지만 e.printStackTrace();으로 쓸 수도 있다.
catch에는 코드가 없어도 괜찮지만, 일반적으로 무엇이 잘못되었는지 정확하게 명시해 준다.

catch 옆에 적어줄 오류클래스는 꼭 그대로 쓸 필요는 없고
그 클래스의 부모클래스인 Exception으로 대부분은 잡을 수 있다.

오류시 오류코드의 위치를 알려주니 그 코드를 try로 묶으면 된다, 근데 코드 전체를 다 묶어도 상관은 없다
트라이-캐치는 오버라이딩이 가능하다. 캐치도 하나의 메소드라고 표현한다

finally 는 트라이-캐치중 어느게 실행되던 실행되는 코드이다.

가끔 변수 밑 노란경고줄은 변수가 닫히지 않았다는것인데.
finally가 무조건 실행되는 점을 생각해 닫아야하는 것들을 finally에 넣을 수 있다.

스캐너는 입력 스트림이라고 부를 수 있다. 저장소와 출력코드를 연결하는 일종의 출입구.

if-else와 다른점은 의도하지 않은 다른 자료형으로 입력이 될 경우 if문은 빨간 에러메세지를 띄우지만,
try-catch문은 그런점까지 다 잡을 수 있다.


-예외전가
throws로 처리한다.예외처리한 내용을 호출한 메소드로 전가하는것.
코드는 깔끔하다 많은 메소드에서 연결되어 사용시 연결된 메소드로 전가된 오류를 해결해주어야하기 때문에 불편함

throws는 예외전가 여서 현재코드는 오류가 없어지더라도 연결되어 있는 다른 메소드로 오류가 옮겨가게 된다.


-강제예외
throw로 처리한다. 개발자의 의도와 다른경우 처리한다.

throw는 강제로 예외 상황을 만드는 경우로

식은
try {
오류가 발생할 수 있는 코드
	if(의도하지 않은 답이 입력되면)
		throw 대응코드
}catch(오류클래스 변수) {
오류 발생시 대응할 코드
}

형태로, 오류가 발생하지 않은 것들에 대해 조건을 주고 그게 만족되면 오류로 처리하도록 하는것.












*/