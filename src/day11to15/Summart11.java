package day11to15;
/*

오버라이딩 overriding
상속받은 메서드의 내용을 변경하는것
부모메소드와 다르게 자신에게 맞게 변경하여 사용한다
-조건
부모메소드의 이름과 동일하게 만들어야 한다
자식의 접근제한자는 부모의 접근제한자보다 작으면 안된다
-private < package < protected < public < default

오버라이딩을 하려면 부모 메소드와 이름이 똑같아야한다
행간 번호 옆 위로 화살표가 끝 부분이 오버라이딩이 되었다는 표시

메소드의 내용이 수정이 없을경우 final을 붙일 수 있다. final을 붙히면 수정이 안된다.
오버라이딩을 금지할때 final을 붙힌다. 상속도 받을 수 없다. new 연산으로 만들어 사용해야함
final class Test03{} 형식

오버라이딩을 하려면 매개변수 갯수, 타입 반환타입까지 전부 일치시켜야 한다.
접근자의 넓이가 부모가 더 크면 오버라이딩이 안된다. 반대는 가능
디폴트가 퍼블릭보다 더 크다

//형변환 = 캐스팅
자식클래스에서 부모클래스로 하는게 업캐스팅, 반대는 다운캐스팅
업캐스팅의 단점은 부모클래스를 업캐스팅하면 부모의 메소드만 사용 가능한것

A01 a;
a = new B01; a.test();
a = new C01; a.test();
둘다 A를 부모로 두고 있다면 부모형식으로 처리 가능하다


object는 조상클래스 /클래스를 만들고 아무것도 넣지 않더라도 object는 자동으로 상속되게 된다.


추상 클래스 Abstract
추상 메소드를 가지고 있는 클래스를 추상 클래스라 한다
-상속
추상 클래스를 상속받는 경우 자식 클래스에서 구현해야 한다.
-사용이유
.다형성을 표현하기 위한 방법
.사용자마다 동작하는 방식이 다르기 때문에 사용자가 직접 구현하도록 만듦
 -추상화로 만들지 않는 경우 사용자가 실수로 구현하지 않을 수 있기 때문에
  미리 만들어 놓고 사용자가 만들게 유도하는 방식

중요한 기능을 상속시키지 못한채 코딩을 끝내버릴 가능성을 막는다>문법적으로만 문제가 없으면 실행이 되기 때문에
일부러 문법에 오류를 만들어 확인할 수 있도록 abstract을 쓴다
다른 클래스로 같은 이름의 메소드를 만들어주면 오류없이 돌아간다


인터페이스 Interface
.추상화 메소드만 포함할 수 있다.
.변수는 static final형식으로만 만들어지며, 값을 초기화해야 한다.
.다중 상속이 가능해진다.
.Up casting을 진행하면 코드를 간결하게 만들 수 있다.

final로 만든 내용은 수정이 불가능하다.

인터페이스는 코드가 있는 메소드를 포함하지 못한다. 추상화만 가능. 
클래스랑 반대되는 개념. 그래서 중괄호{}가 있으면 오류남
클래스는 여러개를 한번에 상속할 수 없다.한개만 가능
인터페이스는 상속 시 'implements'라는 문구가 필요하며 한번에 2개 상속도 가능

인터페이스를 이용하려면 그 내용을 상속받은 클래스에서 실체화를 시켜줘야 한다

인터페이스를 사용하면 객체 만들때 앞쪽을 인터페이스로 만들 수 있으니
후에 수정할때 수정할 코드가 뒷쪽만 있어 코드 수정이 줄어든다.
메소드의 이름을 단일화 시켜줄 수 있다

팀프로젝트간 메소드 이름을 맞춰주는데 유용하다


List<String> s = new ArrayList<>();
Map<String, String> m = new HashMap<>();
어레이리스트의 부모는 리스트, 해쉬맵의 부모는 맵
부모는 인터페이스로 받을것, 자료형이 앞뒤가 다르다면 형변환이 일어난걸 알 수 있다.



싱글턴 패턴 Singleton Pattern
하나의 객체를 만들어 공유해서 사용하는 방식
New연산을 한번만 사용하기 때문에 메모리를 효율적으로 사용할 수 있음
미리 만들어 사용하는 방식이기 때문에 처리 속도도 빠름

//하나의 저장공간을 사용하게 하는 싱글턴, 객체를 하나만 만들고 다른 객체들도 같은 위치의 값을 쓸 수 있도록 함












 */